import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

// AUTO-GENERATED BY next-rewrites-plugin
// DO NOT EDIT DIRECTLY

// Types for rewrites
interface RewriteRule {
  source: string;
  destination: string;
  externalUrl: string;
  featureFlag?: string;
}

// Rewrite rules - will be replaced at runtime
const rewrites: RewriteRule[] = /* REWRITES_JSON_PLACEHOLDER */[];

// Feature flag check function
const isFeatureFlagEnabled = /* FEATURE_FLAG_FUNCTION_PLACEHOLDER */function(flag: string) { return true; };

export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  
  console.log(`[next-rewrites-plugin] Processing request for: ${pathname}`);
  
  // Process through each rewrite rule
  for (const rewrite of rewrites) {
    // Skip inactive rewrite rules based on feature flags
    if (rewrite.featureFlag && !isFeatureFlagEnabled(rewrite.featureFlag)) {
      continue;
    }
    
    // Basic path matching (could be enhanced for path patterns)
    if (matchPath(pathname, rewrite.source)) {
      console.log(`[next-rewrites-plugin] Rewriting ${pathname} to ${rewrite.externalUrl}${getDestinationPath(pathname, rewrite.source, rewrite.destination)}`);
      
      // Create the rewritten URL
      const url = new URL(
        getDestinationPath(pathname, rewrite.source, rewrite.destination),
        rewrite.externalUrl
      );
      
      // Preserve search params
      url.search = request.nextUrl.search;
      
      // Create a rewrite response
      return NextResponse.rewrite(url);
    }
  }
  
  // No matching rewrite rule, continue with the request
  return NextResponse.next();
}

// Path matching with support for dynamic parameters
function matchPath(pathname: string, pattern: string): boolean {
  // Convert pattern to regex
  // This handles basic /:param/* style patterns
  const regex = new RegExp(
    '^' + 
    pattern
      .replace(/\/\:[^\/]+(\*?)/g, '/([^/]+)$1')
      .replace(/\*/g, '.*')
      .replace(/\//g, '\\/') + 
    '$'
  );
  
  return regex.test(pathname);
}

// Handle destination path with parameter substitution
function getDestinationPath(pathname: string, source: string, destination: string): string {
  if (source === pathname) {
    return destination;
  }
  
  // Handle parameter substitution
  const sourceSegments = source.split('/');
  const pathnameSegments = pathname.split('/');
  const destSegments = destination.split('/');
  
  // Collect params from source and pathname
  const params: Record<string, string> = {};
  
  sourceSegments.forEach((segment, i) => {
    if (segment.startsWith(':')) {
      const paramName = segment.substring(1).replace('*', '');
      params[paramName] = pathnameSegments[i] || '';
    }
  });
  
  // Replace params in destination
  return destSegments
    .map(segment => {
      if (segment.startsWith(':')) {
        const paramName = segment.substring(1).replace('*', '');
        return params[paramName] || '';
      }
      return segment;
    })
    .join('/');
}

// Configure middleware to run on all paths
export const config = {
  matcher: [
    // Skip all internal paths
    '/((?!api|_next/static|_next/image|favicon.ico).*)'
  ],
};